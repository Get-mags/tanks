{
  "name": "corridors",
  "version": "0.1.4",
  "description": "Node.js room-managing and configuration library built on top of socket.io",
  "main": "index.js",
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/thatnerd2/corridors.git"
  },
  "keywords": [
    "node.js",
    "socket.io"
  ],
  "author": {
    "name": "Aaron Y. Chan"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/thatnerd2/corridors/issues"
  },
  "homepage": "https://github.com/thatnerd2/corridors#readme",
  "dependencies": {
    "node-uuid": "^1.4.3",
    "socket.io": "^1.3.7"
  },
  "devDependencies": {
    "chai": "^3.4.0",
    "express": "^4.13.3",
    "mocha": "^2.3.3",
    "socket.io-client": "^1.3.7"
  },
  "readme": "Corridors.js\n=========\n\nA lightweight socket.io based library to provide a clean, abstract way to manage web socket rooms and users.\n\n## Installation\n\n  npm install corridors --save\n\n## Usage\n\ncorridors uses a three step process to get up and running: init, configure, and run.  The init phase requires a server (of your creation) to start socket.io.  The configure stage has a series of options that you can pick from, including whether or not to allow room keys, user authentication (set the \"shouldAllowUser: function(user, data)\" hook - default returns true always), maximum members per room.  There are defaults set for everything as well (see Documentation) The run stage applies all the settings.\n\ncorridors also has a reset function that destroys all settings and removes listeners, essentially restoring the state of the system to the init stage.\n\nExample:\n```javascript\nvar app = require('express')();\nvar express = require('express');\nvar server = require('http').Server(app);\nvar corridors = require('corridors');\n\napp.use(express.static('public'));\nserver.listen(4004);\n\ncorridors.init(server);\n\ncorridors.configure({\n  maxMembers: 3,\n  allowKeys: true,\n  messages: {\n    \"say\":function (user, data) {\n      user.room._tellRoom(\"new message\", {message: data.message, name: user.name});\n    }\n  },\n  configureRoom: {\n    // Properties and methods of each room can be put here.\n  },\n  configureUser: {\n    name: \"\"\n  },\n  onRegistrationSuccess: function (user, data) {\n    user.name = data.name\n  }\n});\ncorridors.run();\n```\n\nThe client side of corridor (included in install, very small file) is essentially a method that applies special listeners to sockets.  Here's an example of multiple clients connecting, and one client sending a message while the other receives it.\n```javascript\n\nvar socket = io.connect(\"http://localhost:4004\");\ncorridorify(socket, {\n  registrationData: {\n    name: \"testuser!\"\n  },\n  onConnect: function () {\n    console.log(\"I am connected and ready\");\n  },\n  onReject: function () {\n    console.log(\"I was rejected!\");\n  }\n});\n```\n\n## Settings\nThe options for configuration of the server can be found in the defaults of the index.js file of corridors - each option has a default:\n```javascript\nvar defaults = {\n  maxMembers: 1,\n  allowKeys: true,\n  userToRoomImmediately: false,\n  shouldAllowUser: function (socket, data) {\n    return true;\n  },\n  onRegistrationSuccess: function (user, registrationData) {},\n  messages: {},\n  configureRoom: {\n    begin: function () {},\n    removeMember: function (user) {}\n  },\n  configureUser: {}\n};\n```\nEach of the functions or settings above does something, including the functions.  The settings for the client side corridors are as follows:\n```javascript\nvar defaults = {\n  registrationData: {\n    roomKey: null\n  },\n  onConnect: function () {},\n  onReject: function () {}\n};\n```\nwhere onConnect happens when the socket makes connection with the server (but is not registered, thus not put into a room or lobby yet), and onReject occurs when the user is asking for a room that is already full, or doesn't meet the authentication requirements specified in the server side \"shouldAllowUser\" function, etc.  The registration data parameter can hold any information (must have the roomKey), and you can access that data by the onRegistrationSuccess server side function.\n\n## Notes\nRoom keys are more like requests than keys.  Let's say Bob and Joe want to go to a private room to chat.  They can make up their own room name, like \"fort\" and use that as their room key.  Thus, only people who use the room key \"fort\" can get into their room.  Also, allowing keys still allows \"null\" as a key.  Entering \"null\" as a key is synonymous with no preference, so the room id will be generated by uuid.  If room names conflict, the users who requested the room last will have to pick a different key.  Keys must be unique.\n\nFor more help, feel free to contact me with suggestions or questions.\n\n## Tests\n\n  npm test\n\n## Contributing\n\nPlease make sure that for any new or changed functionality, unit tests are also\nprovided.  I would also like to be notified if possible.\n\n## Release History\n\n* 0.1.0 Initial release\n* 0.1.1 Updated readme\n* 0.1.2 Added room key functionality, authentication hook.\n* 0.1.3 Added server-side registration hook (onRegistrationSuccess), fixed browser-reload bug\n* 0.1.4 Added server-side userToRoomImmediately setting and associated tests.",
  "readmeFilename": "README.md",
  "gitHead": "02b457663c904cd8f4ff0d4f35cb2a964f3c341a",
  "_id": "corridors@0.1.4",
  "_shasum": "7284f68aca4a2a23ed685b901f87674c57b7eb2b",
  "_from": "corridors@*"
}
